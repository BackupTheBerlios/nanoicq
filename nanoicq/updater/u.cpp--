
#include <iostream>
#include <list>
#include <sstream>

//#include <windows.h>
#include <afxwin.h>

#include "MD5Checksum.h"

using namespace std;

template <typename T, typename S>
T stream_cast(S const& val) {
    stringstream stream;
    stream << val;
    T rc;
    stream >> rc;
    return rc;
}

#define ZZ cerr << __FILE__ << ":" << __LINE__ << endl;

//typedef struct _WIN32_FIND_DATA {
//  DWORD dwFileAttributes;
//  FILETIME ftCreationTime;
//  FILETIME ftLastAccessTime;
//  FILETIME ftLastWriteTime;
//  DWORD nFileSizeHigh;
//  DWORD nFileSizeLow;
//  DWORD dwReserved0;
//  DWORD dwReserved1;
//  TCHAR cFileName[MAX_PATH];
//  TCHAR cAlternateFileName[14];
//} WIN32_FIND_DATA, 
//*PWIN32_FIND_DATA, 
//*LPWIN32_FIND_DATA;

class Item {
    string fileName_;
    string md5_;
    FILETIME modTime_;

public:
    Item(const string& fileName, const string& md5, FILETIME modTime) :
        fileName_(fileName), md5_(md5), modTime_(modTime) {
    }

    bool operator==(const Item& item) {
        return fileName_.compare(item.fileName_) && md5_.compare(item.md5_) &&
            modTime_.dwLowDateTime == item.modTime_.dwLowDateTime &&
            modTime_.dwHighDateTime == item.modTime_.dwHighDateTime
            ;
    }

    friend ostream& operator<<(ostream& ofs, Item v) {
        ofs << v.fileName_.c_str()
            << " " << v.modTime_.dwLowDateTime 
            << v.modTime_.dwHighDateTime 
            << " " << v.md5_.c_str();
        return ofs;
    }

};

class A {
    WIN32_FIND_DATA findData;

public:
    void dumpList(const list<string>& lst) {
        cout << "Directories:" << endl;
        for(list<string>::const_iterator it = lst.begin(); it != lst.end(); it++) {
            cout << (*it).c_str() << endl;
        }
    }

    HANDLE ff(LPCTSTR curdir) {
        static HANDLE hFind = FindFirstFile(curdir, &findData);
        if (hFind == INVALID_HANDLE_VALUE) {
            printf("Invalid File Handle. GetLastError reports %d\n", 
                GetLastError ());
        }
        return hFind;
    }

    bool traverse(string curdir, list<Item>& result) {
        bool rc = true;
        const char* top = strdup(curdir.c_str());
        list<string> dirs;
        HANDLE hFind = 0;

        dirs.push_back(curdir);

        while(!dirs.empty()) {

            curdir = dirs.front();
            dirs.pop_front();
            curdir += "\\*";

            printf("Going to %s\n", curdir.c_str());

            FindClose(hFind);
            hFind = FindFirstFile(curdir.c_str(), &findData);

            if (hFind == INVALID_HANDLE_VALUE) {
                DWORD errCode = GetLastError();

                if(errCode == ERROR_NO_MORE_FILES) {
                    // exit gracefully
                    printf("No more files in current directory\n");
                    continue;
                }

                printf("Invalid File Handle. GetLastError reports %d\n", 
                    errCode);
                break;
            }

            while(FindNextFile(hFind, &findData)) {
                if( (strcmp(findData.cFileName, ".") == 0) || ((strcmp(findData.cFileName, "..") == 0)) ) {
                    printf("[%s] Skipping . and ..\n", curdir.c_str());
                    continue;
                }

                if(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    printf("%s is directory\n", findData.cFileName);

                    string tmp = curdir.substr(0, curdir.length() - 1);
                    tmp += findData.cFileName;
                    dirs.push_back(tmp);
                } else {
                    if(findData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                        printf("%s is read only\n", findData.cFileName);
                    } else {
                        printf("%s looks like file\n", findData.cFileName);

                        string fullFileName = curdir.substr(0, curdir.length() - 1);
                        fullFileName += findData.cFileName;
                        string md5 = CMD5Checksum::GetMD5(fullFileName.c_str());

                        result.push_back(Item(fullFileName, md5,
                            findData.ftLastWriteTime));

                        cout << md5.c_str() << endl;
                    }
                }
                
            }
        }

        dumpList(dirs);

        return rc;
    }
};

int main(int argc, char** argv) {
    A a;

    list<Item> result;
    if(argc == 1)
        a.traverse(".", result);
    else
        a.traverse(argv[1], result);
#if 0
    list<Item> items;
    for(int ii = 0; ii < 10; ii++) {
        string f, m;
        f = stream_cast<string>(ii);
        m = stream_cast<string>(ii + 100);
        Item item(f, m);
        items.push_back(item);
    }
#endif

    for(list<Item>::const_iterator it = result.begin(); it != result.end(); it++) {
        cout << (Item)(*it) << endl;
    }

    return 0;
}
